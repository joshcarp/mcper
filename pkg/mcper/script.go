package mcper

import (
	"fmt"
	"os"
	"regexp"
	"strings"
)

const (
	// ConfigStartMarker marks the beginning of embedded JSON config
	ConfigStartMarker = "###MCPER_CONFIG_START###"
	// ConfigEndMarker marks the end of embedded JSON config
	ConfigEndMarker = "###MCPER_CONFIG_END###"

	// StartScriptName is the name of the bootstrap script
	StartScriptName = "start.sh"

	// InstallURL is the URL for the mcper install script
	InstallURL = "https://raw.githubusercontent.com/joshcarp/mcper/main/scripts/release/install.sh"
)

// StartScriptTemplate is the template for .mcper/start.sh
const StartScriptTemplate = `#!/bin/bash
# Generated by mcper init - edit freely
set -uo pipefail

MCPER_VERSION="%s"
MCPER_BIN="$HOME/.mcper/bin/mcper"

# Log startup to help debug issues
LOGFILE="$HOME/.mcper/start.log"
mkdir -p "$HOME/.mcper"
echo "=== start.sh running at $(date) ===" >> "$LOGFILE"
echo "PWD: $(pwd)" >> "$LOGFILE"
echo "MCPER_VERSION: $MCPER_VERSION" >> "$LOGFILE"

###MCPER_CONFIG_START###
CONFIG='%s'
###MCPER_CONFIG_END###

# Bootstrap mcper if needed (check binary directly, not PATH)
if [ ! -x "$MCPER_BIN" ]; then
  echo "Installing mcper v${MCPER_VERSION}..." >> "$LOGFILE"
  curl -sSL https://raw.githubusercontent.com/joshcarp/mcper/main/scripts/release/install.sh | sh -s -- "$MCPER_VERSION" >> "$LOGFILE" 2>&1 || true
fi

if [ ! -x "$MCPER_BIN" ]; then
  echo "ERROR: mcper binary not found at $MCPER_BIN" >> "$LOGFILE"
  exit 1
fi

echo "mcper path: $MCPER_BIN" >> "$LOGFILE"
echo "Starting mcper serve..." >> "$LOGFILE"

exec "$MCPER_BIN" serve --config-json "$CONFIG" 2>> "$LOGFILE"
`

// ParseStartScript extracts the config from a start.sh file
func ParseStartScript(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read start script: %w", err)
	}

	return ParseStartScriptContent(string(data))
}

// ParseStartScriptContent extracts the config from start.sh content
func ParseStartScriptContent(content string) (*Config, error) {
	// Find content between markers
	startIdx := strings.Index(content, ConfigStartMarker)
	endIdx := strings.Index(content, ConfigEndMarker)

	if startIdx == -1 || endIdx == -1 {
		return nil, fmt.Errorf("could not find config markers in start script")
	}

	// Extract the config section
	configSection := content[startIdx+len(ConfigStartMarker) : endIdx]

	// Extract JSON from CONFIG='...'
	re := regexp.MustCompile(`CONFIG='([^']*)'`)
	matches := re.FindStringSubmatch(configSection)
	if len(matches) < 2 {
		return nil, fmt.Errorf("could not extract CONFIG value from start script")
	}

	jsonStr := matches[1]
	return ParseConfig([]byte(jsonStr))
}

// UpdateStartScript updates the config in a start.sh file
func UpdateStartScript(path string, config *Config) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read start script: %w", err)
	}

	content := string(data)

	// Find markers
	startIdx := strings.Index(content, ConfigStartMarker)
	endIdx := strings.Index(content, ConfigEndMarker)

	if startIdx == -1 || endIdx == -1 {
		return fmt.Errorf("could not find config markers in start script")
	}

	// Generate new config section
	jsonBytes, err := config.ToJSON()
	if err != nil {
		return fmt.Errorf("failed to serialize config: %w", err)
	}

	// Build the new config section
	newConfigSection := fmt.Sprintf("%s\nCONFIG='%s'\n%s",
		ConfigStartMarker,
		string(jsonBytes),
		ConfigEndMarker,
	)

	// Replace the old config section
	newContent := content[:startIdx] + newConfigSection + content[endIdx+len(ConfigEndMarker):]

	return os.WriteFile(path, []byte(newContent), 0755)
}

// GenerateStartScript creates a new start.sh content
func GenerateStartScript(config *Config) (string, error) {
	jsonBytes, err := config.ToJSON()
	if err != nil {
		return "", fmt.Errorf("failed to serialize config: %w", err)
	}

	return fmt.Sprintf(StartScriptTemplate, Version, string(jsonBytes)), nil
}

// WriteStartScript writes a start.sh file to the specified path
func WriteStartScript(path string, config *Config) error {
	content, err := GenerateStartScript(config)
	if err != nil {
		return err
	}

	return os.WriteFile(path, []byte(content), 0755)
}
